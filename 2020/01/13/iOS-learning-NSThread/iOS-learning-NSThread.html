<hr>
<h2 id="title-dart-注解实现以及代码生成原理"><a href="#title-dart-注解实现以及代码生成原理" class="headerlink" title="title: dart 注解实现以及代码生成原理"></a>title: dart 注解实现以及代码生成原理</h2><font color="black" face="黑体" size="6"><center>dart 注解实现以及代码生成原理</center></font><br><font color="red" size="2"><center>花生-sniper</center></font>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><ul>
<li>先创建线程，再启动线程<br><code>`</code><br>// 1. 创建线程<br>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];<br>// 2. 启动线程<br>[thread start];    // 线程一启动，就会在线程thread中执行self的run方法<br>// 新线程调用方法，里边为需要执行的任务</li>
</ul>
<ul>
<li>(void)run {<br>   NSLog(@”%@”, [NSThread currentThread]);<br>}<br><code>`</code></li>
</ul>
<ul>
<li>创建线程后自动启动线程<br><code>`</code><br>// 1. 创建线程后自动启动线程<br>[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</li>
</ul>
<p>// 新线程调用方法，里边为需要执行的任务</p>
<ul>
<li>(void)run {<br>   NSLog(@”%@”, [NSThread currentThread]);<br>}<br><code>`</code></li>
</ul>
<ul>
<li>隐式创建并启动线程<br><code>`</code><br>// 1. 隐式创建并启动线程<br>[self performSelectorInBackground:@selector(run) withObject:nil];</li>
</ul>
<p>// 新线程调用方法，里边为需要执行的任务</p>
<ul>
<li>(void)run {<br>   NSLog(@”%@”, [NSThread currentThread]);<br>}<br><code>`</code></li>
</ul>
<h4 id="状态控制"><a href="#状态控制" class="headerlink" title="状态控制"></a>状态控制</h4><ul>
<li>启动线程<br><code>`</code></li>
</ul>
<ul>
<li>(void)start;<br>// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态<br><code>`</code></li>
</ul>
<ul>
<li>阻塞线程<br><code>`</code></li>
</ul>
<ul>
<li>(void)sleepUntilDate:(NSDate *)date;</li>
<li>(void)sleepForTimeInterval:(NSTimeInterval)ti;<br>// 线程进入阻塞状态<br><code>`</code></li>
</ul>
<ul>
<li>终止线程<br><code>`</code></li>
</ul>
<ul>
<li>(void)exit;<br>// 线程进入死亡状态<br><code>`</code></li>
</ul>
<h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。</p>
<pre><code>// 在主线程上执行操作
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&lt;NSString *&gt; *)array;
  // equivalent to the first method with kCFRunLoopCommonModes

// 在指定线程上执行操作
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);

// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法
- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
</code></pre><h4 id="线程安全和线程同步"><a href="#线程安全和线程同步" class="headerlink" title="线程安全和线程同步"></a>线程安全和线程同步</h4><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。</p>
<ul>
<li>@synchronized</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>pthread_mutex</li>
<li>dispatch_semaphore</li>
<li>OSSpinLock</li>
<li>atomic(property) set/get</li>
</ul>
<h4 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h4><ul>
<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。<br>图示如下：<br><img src="./thread-state-transfer.png" alt=""></li>
</ul>
